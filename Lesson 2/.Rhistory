sapply(s, function(x) colMeans(x[, c("Sepal.Length")]))
s
sapply(s, colMeans(iris[,c("Sepal.Length")]))
library(datasets)
data(iris)
View(iris)
s <-split(iris, iris$Species)
sapply(s, function(x) colMeans(x[, c("Sepal.Length")]))
?tracback
?traceback
library(datasets)
data(iris)
View(iris)
s <- split(iris, iris$Species)
sapply(s, functions(iris) colMeans(iris[, c("Sepal.Length")]))
sapply(s, functions(iris) colMeans(iris[, c("Sepal.Length", "Sepal.Width")]))
sapply(s, functions(iris) mean(iris[, c("Sepal.Length", "Sepal.Width")]))
sapply(s, functions(iris) colMeans(iris[,c("Sepal.Length")]))
sapply(s, functions(x) colMeans(x[,c("Sepal.Length")]))
sapply(s, functions(x) colMeans(x[,c("Sepal.Length")]))
sapply(s, functions(iris) colMeans(iris[,c("Sepal.Length")]))
sapply(s, functions(iris) colMeans(iris[,c("Sepal.Length")]))
sapply(s, function(iris) colMeans(iris[,c("Sepal.Length")]))
sapply(s, function(iris) colMeans(iris[,c("Sepal.Length", "Sepal.Width")]))
?sapply
?mean
sapply(s, function(x) colMeans(x[,c("Sepal.Length", "Sepal.Width")]))
?function
?function()
sapply(s, function(iris) colMeans(iris[,c("Sepal.Length", "Sepal.Width")]))
sapply(s, function(iris) mean(iris[,c("Sepal.Length")]))
sapply(s, function(iris) colMeans(iris[,c("Sepal.Length", "Sepal.Width")]))
?export
?write
write(iris, file="C:\Users\Frank\Desktop\Coursera Classes\R Programming\IRIS")
write.table(iris, "C:\Users\Frank\Desktop\Coursera Classes\R Programming\IRIS.txt", sep="\t")
write.table(iris, "C:/Users/Frank/Desktop/Coursera Classes/R Programming/IRIS.txt", sep="\t")
?apply
colMeans(iris)
apply(iris, 2, mean)
apply(iris[,1:4], 2, mean)
a <- apply(iris[,1:4], 2, mean)
fix(a)
attributes(a)
dim(a)
typeof(a)
class(a)
a
apply(iris[,1:4],1,mean)
rowMeans(iris[,1:4])
apply(iris[,1:4], 2, mean)
data(mtcars)
View(mtcars)
?mtcars
y <- split(mtcars, mtcars$cyl)
y
sapply(y, function(car) mean(car[,c("mpg")]))
write.table(mtcars, "C:/Users/Frank/Desktop/Coursera Classes/R Programming/car.txt", sep="\t")
sapply(y, function(car) mean(car[,c("mpg")]))
mean(mtcars$mpg, mtcars$cyl)
tapply(mtcars$mpg, mtcars$cyl, mean)
?tapply
hpavg <- tapply(mtcars$hp, mtcars$cyl, mean)
hpavg
hpavg[1]
hpavg[3]
?abs
absdiff <- abs(hpavg[1] - hpavg[3])
absdiff
absdiff <- abs(hpavg[3] - hpavg[1])
absdiff
absdiff <- abs(hpavg[1] - hpavg[3])
absdiff
hpavg <- tapply(mtcars$hp, mtcars$cyl, mean)
hpavg
absdiff <- abs(hpavg[1] - hpavg[3])
absdiff
f <- function(x){
g <-function(y){
y+z
}
z <-4
x +g(x)
}
}
f <- function(x){
g <-function(y){
y+z
}
z <-4
x +g(x)
}
z <- 10
f(3)
z <- 10
f(3)
z <- 10
f(3)
debug(ls)
ls
debug(lm)
lm(y~x)
n
n
n
n
n
n
n
n
n
n
n
debug(ls)
ls
n
debug(lm)
lm(y~x)
n
n
n
n
n
n
n
n
n
n
debug(ls)
ls
?ls
debug(ls)
ls()
n
n
n
n
n
n
n
sapply(split(mtcars$mpg,mtcars$cyl),mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
library(forecast)
library(lmtest)
library(caret)
library(xts)
library(TTR)
?sma
?SMA
RawData <- read.csv("C:/Users/Frank/Desktop/Coursera Classes/R Programming/Week 1/Quiz")
RawData <- read.csv("C:/Users/Frank/Desktop/Coursera Classes/R Programming/Week 1/Quiz/Week1Quiz.R")
View(RawData)
RawData <- read.csv("C:/Users/Frank/Desktop/Coursera Classes/R Programming/Week 1/Quiz/hw1_data.csv")
View(RawData)
x <- 4L
class(x)
x <- c(4, "a", TRUE)
class(x)
x <-c(1,3,5)
y <-c(3,2,10)
rbind(x,y)
x <- list(2, "a", "b", TRUE)
x[[1]]
class(x[[1]])
class(x)
class(x[[2]])
x <- 1:4
y <- 2
x
y
x+y
class(x+y)
x <- c(3, 5, 1, 10, 12, 6)
x
x[x > 6] <- 0
x
x <- c(3, 5, 1, 10, 12, 6)
x
x[x < 6] == 0
x <- c(3, 5, 1, 10, 12, 6)
x <- c(3, 5, 1, 10, 12, 6)
x <- c(3, 5, 1, 10, 12, 6)
x
x[x == 0] <- 6
x
x <- c(3, 5, 1, 10, 12, 6)
x[x %in% 1:5] <- 0
x
RawData <- read.csv("C:/Users/Frank/Desktop/Coursera Classes/R Programming/Week 1/Quiz/hw1_data.csv")
col.names(RawData)
class(RawData)
colnames(RawData)
?head
head(RawData, 2)
?nrow
nrow(RawData)
tail(RawData, 2)
RawData[47,]
sum(is.na(RawData$Ozone))
Bad <- is.na(RawData$Ozone)
Ozone1 <- RawData$Ozone[!Bad]
mean(Ozone1)
Q8 <-subset(RawData,Ozone>31 & Temp>90)
mean(Q8$Solar.R)
Q9 <- subset(RawData,Month==6)
mean(Q9$Temp)
# Q20 What was the maximum ozone value in the month of May (i.e. Month = 5)?
maximum ozone value in the month of May (i.e. Month = 5)?
Q10 <-subset(RawData,Month==5)
Bad1 <- is.na(Q10$Ozone)
Ozone2 <-Q10$Ozone[!Bad1]
max(Ozone2)
Q10Test <-subset(RawData,Month==5 & Ozone!=is.na(Ozone))
max(Q10Test$Ozone)
cube <- function(x, n) {
x^3
}
cube(3)
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
v1 <- [1,2,3]
v1 <- 1:3
v2 <- 4:36
v2 <- 4:6
v2 <- 7:9
v2 <- 4:6
v23 <- 7:9
v3 <- 7:9
v1 <- 1:3
v2 <- 4:6
v3 <- 7:9
daMatrix <- c(v1,v2,v3)
?matrix
matrix(nrow = 3, ncol = 3)
matrix(nrow = 3, ncol = 3, data=1:9)
?solve
matrix(nrow=2,ncol=2)
test <- matrix(nrow=2,ncol=2)
test[[1,1]] <- 2
test[[1,2]] <- 3
test[[2,1]] <- 2
test[[2,2]] <- 2
test
solve(test)
v1 <- (1,2)
v1 <- 1,2
v1 <- vector(1, 8, -9, 7, 5()
v1 <- vector(1, 8, -9, 7, 5)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
test <- c(1:10)
trace?
?trace
trace(makeVector(test))
trace(test, makeVector)
?debugonce
debugonce(makeVector(test))
makeVector(test)
test1 <- makeVector(test)
test1
cachemean(test)
?sample
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
# This function creates a list of subfunctions which can
# define a matrix, retrieve a matrix,
# cache a matrix, and retrieve cached matrix
makeCacheMatrix <- function(x = matrix()) {
#If object called without method
cache <- NULL
#Defines Matrix
setMat <- function(y){
x <<- y
cache <<- NULL
}
#Retrieves Matrix
getMat <- function()x
#Saving into cache
saveMatrix <- function(inverse) cache <<- inverse
#Retrieving from cache
getMatrix <- function()cache
list(setMat = setMat, getMat = getMat,
saveMatrix  = saveMatrix,
getMatrix = getMatrix)
}
## Write a short comment describing this function
# This function is able to check to see if a inverse
# of a matrix has already been calculated and cached.
# If not, then it goes ahead and calculates the inverse.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
cache <- x$getMatrix()
#checks to see if inverse already solved;
#if so then returns cached inverse
if(!is.null(cache)){
message("Retrieving cached inverse")
return(cache)
}
#Retrieves matrix
theMatrix <- x$getMat()
#solves for inverse
cache <- solve(theMatrix, ...)
#Store inverse into cache
x$saveMatrix(cache)
#Returns inverse to user
cache
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$getMat()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
# This function creates a list of subfunctions which can
# define a matrix, retrieve a matrix,
# cache a matrix, and retrieve cached matrix
makeCacheMatrix <- function(x = matrix()) {
#If object called without method
cache <- NULL
#Defines Matrix
setMat <- function(y){
x <<- y
cache <<- NULL
}
#Retrieves Matrix
getMat <- function()x
#Saving into cache
saveMatrix <- function(inverse) cache <<- inverse
#Retrieving from cache
getMatrix <- function()cache
list(setMat = setMat, getMat = getMat,
saveMatrix  = saveMatrix,
getMatrix = getMatrix)
}
## Write a short comment describing this function
# This function is able to check to see if a inverse
# of a matrix has already been calculated and cached.
# If not, then it goes ahead and calculates the inverse.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
cache <- x$getMatrix()
#checks to see if inverse already solved;
#if so then returns cached inverse
if(!is.null(cache)){
message("Retrieving cached inverse")
return(cache)
}
#Retrieves matrix
theMatrix <- x$getMat()
#solves for inverse
cache <- solve(theMatrix, ...)
#Store inverse into cache
x$saveMatrix(cache)
#Returns inverse to user
cache
}
# #Test Code to confirm functions work
# amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
# amatrix$getMat()
# cacheSolve(amatrix)
# amatrix$getMatrix()
# cacheSolve(amatrix)
#
# amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
# cacheSolve(amatrix)
# amatrix$getMat()
# amatrix$getMatrix()
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$getMat()
cacheSolve(amatrix)
amatrix$getMatrix()
cacheSolve(amatrix)
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
cacheSolve(amatrix)
amatrix$getMat()
amatrix$getMatrix()
## Put comments here that give an overall description of what your
## functions do
# In the makeCacheMatrix function, it is a function
# which has 4 subfunctions:
# setMat, getMat, saveMatrix, and getMatrix.
# setMat purpose is to have a matrix passed
# through it and then store it as x. It also
# clears the cache. getMat purpose is to grab
# the matrix that might be stored in x and then
# return it.saveMatrix's purpose is to save
# into cache the inversed matrix. getMatrix's
# purpose is to retrieve the cached inverse
# matrix.
#
# In the cacheSolve funciton, its purpose
# is to check to see if an inverse has already
# been calculated. If it has, then it will retrieve
# the matrix inverse from the cache. If not, it
# will proceeed calculating the inverse of the matrix.
## Write a short comment describing this function
# This function creates a list of subfunctions which can
# define a matrix, retrieve a matrix,
# cache a matrix, and retrieve cached matrix
makeCacheMatrix <- function(x = matrix()) {
#If object called without method
cache <- NULL
#Defines Matrix
setMat <- function(y){
x <<- y
cache <<- NULL
}
#Retrieves Matrix
getMat <- function()x
#Saving into cache
saveMatrix <- function(inverse) cache <<- inverse
#Retrieving from cache
getMatrix <- function()cache
list(setMat = setMat, getMat = getMat,
saveMatrix  = saveMatrix,
getMatrix = getMatrix)
}
## Write a short comment describing this function
# This function is able to check to see if a inverse
# of a matrix has already been calculated and cached.
# If not, then it goes ahead and calculates the inverse.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
cache <- x$getMatrix()
#checks to see if inverse already solved;
#if so then returns cached inverse
if(!is.null(cache)){
message("Retrieving cached inverse")
return(cache)
}
#Retrieves matrix
theMatrix <- x$getMat()
#solves for inverse
cache <- solve(theMatrix, ...)
#Store inverse into cache
x$saveMatrix(cache)
#Returns inverse to user
cache
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$getMat() # Returns original matrix
cacheSolve(amatrix) # Computes, caches, and returns matrix inverse
amatrix$getMatrix() # Returns matrix inverse
cacheSolve(amatrix) # Returns cached matrix inverse using previously computed matrix inverse
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2)) # Modify existing matrix
cacheSolve(amatrix) # Computes, caches, and returns new matrix inverse
amatrix$getMat() # Returns matrix
amatrix$getMatrix() # Returns matrix inverse
require(quantmod)
yahooQF()
getQuote()
install.packages('quantmod')
require(quantmod)
yahooQF()
df <- read.csv('weather_underground.csv')
setwd('C:/Users/Frank/Desktop/Data Science Cert/Udacity/Intro_to_Data_Science/UdacityIntroToDataScience/Lesson 2')
df <- read.csv('weather_underground.csv')
View(df)
names(df)
summary(df$rain)
beforeDF <- read.csv('turnstile_110528.txt')
afterDF <- read.csv('solution_turnstile_110528.txt')
View(beforeDF)
View(afterDF)
View(beforeDF)
beforeDF <- read.csv('turnstile_110528.txt', header=FALSE)
View(beforeDF)
afterDF <- read.csv('solution_turnstile_110528.txt', header=FALSE)
View(beforeDF)
View(afterDF)
